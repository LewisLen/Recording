<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">
		
		let data = {
			book:{
				prdCode: 'BOOK0001',
				detail:{
					price: '69',
					subscribe:{
						title: 'Kindle'
					}
				}
			},
			msg: '书籍是人类进步的阶梯',
			arr: [1,3,3,4]
		}

		var uid = 0;
		class Dep{
			constructor(){
				console.log('Dep类');
				this.id = uid++;
				// 订阅者存储。存放wather实例
				this.subs = [];
			}
			// 添加订阅
			addSub(sub){
				thi.subs.push(sub)
			}
			// 添加依赖
			depend(){
				// Dep.target全局唯一值
				if(Dep.target){
					this.addSub(Dep.target);
				}
			}
			notify(){
				console.log('notify函数通知视图更新')
				// 潜复制
				const subs = this.subs.slice();
				for(let i = 0;i<subs.length;i++){
					subs[i].update();
				}
			}
		}

		class Watcher{
			constructor(){
				console.log('Watcher类')
			}
		}

		// 判断是实例属性还是原型属性
		function hasPrototypeProperty(obj, key) {
			// 实例属性：false，原型属性：true
			return !obj.hasOwnProperty(key) && (key in obj);
		}

		// 相当于声明了一个val变量来做初始值和连接get和set，使val和getter/setter函数形成一个闭包
		function defineReactive(data,key,val){
			// 在__ob__属性中新增一个Dep实例
			let dep = new Dep();
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				// 这里如果有多层嵌套对象，那么val就会是下一个嵌套的对象
				// 这里的val = data[key]以及observe(val)对于循环对象变成响应式对象非常关键，会将一个嵌套对象defineReactive完之后再回到外层defineReactive，然后继续下一个data的对象defineReactive
				// var = {a:'aa',b:{c:'cc'},d:'dd'} defineReactive顺序为 a -> c -> b -> d;
				val = data[key]
			}
			// 这里调用obseve的作用是循环递归各个层级的对象，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
			// 被defineReactive化的属性都通过闭包引用属于自己的 Dep 实例和 childOb对象
			// 这里的childOb就是Observer的实例
			let childOb = observe(val);
			Object.defineProperty(data,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，属性==== ',key ,'  val值====  ',val)
					if(Dep.target){
						// 收集依赖
						dep.depend()
						if(childOb) childOb.dep.depend();
					}
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用val的值=== ',val,'  newValue的值===  ',newValue);
					// 当设置属性为对象的时候也要observe，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
					observe(val);
					if(newValue === val) return;
					val = newValue
					console.log("数据被改变此处可更新视图");
					// 通知视图更新
					dep.notify();
				}
			})
		}

		// 将传入的对象走一层Object.deineProperty方法来定义其属性
		const def = (obj,key,value,enumerable) => {
			// 这里传进来的value值是Observer的实例，属性是__ob__ 也就是通过观察对象上是否有__ob__属性来判断对象是否有setter和getter函数，是否被响应式处理
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,// 是否可枚举
				writable: true, // 是否可写
				configurable: true // 
			})
		}


		const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
		// 获取数组原型对象，原型对象上有数组方法如push\pop等
		const arrayProto = Array.prototype;
		// 以数组原型对象(arrayProto)为原型，创建一个原型对象上含有数组方法的对象
		const newArrayPrototypeObj = Object.create(arrayProto);
		console.log(newArrayPrototypeObj instanceof Array)
		arrMethods.forEach(methodName => {
			// 保存数组原型上的方法
			const original = arrayProto[methodName];
			def(newArrayPrototypeObj,methodName,function(...arguments){
				// 用到this，不能用箭头函数
				// arrMethods也有数组原型中的方法了
				console.log('改写数组方法')
				// original.apply(this,arguments);
			},false)
		})

		// 实现各个层级对象的属性能够被侦测（即被观察observe，添加getter和setter函数）的类，有多少个对象就有多少个Observer实例
		class Observer{
			constructor(obj){
				console.log('Observer观察者类，obj值===',obj);
				// 新增一个Dep类实例，每个Observer的实例都会有个Dep实例
				let dep = new Dep();
				// 将类的实例用defineProperty定义属性，这里的this是Observer的实例，所以数据对象的__ob__其实就是Observer的实例
				def(obj,'__ob__',this);
				console.log('Observer====obj',obj);
				if(Array.isArray(obj)){
					// 数组需要通过改写数组方法来使其可以新增getter和setter方法，变成响应式
					Object.setPrototypeOf(obj,newArrayPrototypeObj);
					this.observeArray(obj);
				}else{
					this.walk(obj)
				}
			}
			// 遍历每个对象的层级
			walk (obj) {
				// data属性组成的数组
				const keys = Object.keys(obj)
				for (let i = 0; i < keys.length; i++) {
					// 给data属性对象添加getter和setter方法
					defineReactive(obj, keys[i])
				}
			}
			observeArray (arr) {
				console.log('arr===',arr)
				for (let i = 0, l = arr.length; i < l; i++) {
					observe(arr[i])
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			// 必须保证要观察的data是对象
			if(typeof obj !== 'object' || obj === null) return;
			// ob变量存储的是Observer的实例，__ob__是Observer实例
			var ob;
			// 初始的ob是undefined，通过new Observer的目的是让ob成为Observer的实例，在Observer上通过def来定义__ob__属性，即可给data上的每个对象添加__ob__属性
			if(typeof obj.__ob__ !== 'undefined'){
				ob = obj.__ob__;
			}else{
				ob = new Observer(obj);
			}
			// 最终返回的ob都是Observer实例，最终的目的是给data上的每个对象新增getter和setter方法，同时也会新增一个__ob__实例属性，即实现响应式
			return ob;
		}


		function arrayMethodsChange(){
			const arrMethods = ['push','pop','unshift','shift','splice','sort','reserve'];
			// 获取数组原型上的方法
			const arrayProto = Array.prototype;
			// 以arrayProto为原型,创建一个含有数组方法的对象
			// 即newArrayPrototypeObj是一个有上被述改写的9个数组方法
			const newArrayPrototypeObj = Object.create(arrayProto);
			arrMethods.forEach(methodName => {
				// 保存数组原型上的方法
				const original = arrayProto[methodName];
				def(newArrayPrototypeObj,methodName,function(...arguments){
					// 用到this，不能用箭头函数
					// arrMethods也有数组原型中的方法了
					// arguments不是数组，是伪数组，所以是没有数组的方法

					// todo 这一段还不是很懂
					// 这里的this.__ob__就是传入的data数组中会有__ob__属性，因为该数组也是data对象的一个属性值，所以在遍历最外层对象的时候，就已经给数组添加了__ob__属性
					const ob = this.__ob__;
					let inserted = [];
					let args = [...arguments]
					// 这里判读的目的是将新插入的元素也要是响应式
					switch(methodName){
						case 'push':
						case 'unshift':
							inserted = args;
							break;
						case 'splice':
							// splice(index,number,插入项)
							// 所以这里是从第二项开始取子数组
							inserted = args.splice(2);
							break;
					}
					if(inserted){
						ob.observeArray(inserted);
					}
					// todo 这一段还不是很懂

					console.log('数组数据被改变')
					original.apply(this,arguments);
				},false)
			})
			return newArrayPrototypeObj;
		}

		observe(data);


		// 简写版本
		/*
			const data = {
				data:{
					list:{
						type: '类型111'
					}
				}
			}

			function observer(data){
				if(typeof data !== 'object' || data === null){
					return data
				}
				for(let key in data){
					defineReactive(data,key,data[key]);
				}
			}


			function defineReactive(data,key,value){
				// 递归监听数据中的嵌套对象
				observer(value);
				Object.defineProperty(data,key,{
					get(){
						return value
					},
					set(newValue){
						// 在设置的时候也有可能是对象，也需要深度监听对象
						observer(value);
						if(newValue === value) return;
						val = newValue;
						console.log('更新视图')
					}
				})
			}

			observer(data);
			console.log(data)
			// 删除和新增data没有的属性没法响应式

			// 	新增对数组的响应式
			const oldArrayProto = Array.prototype;
			const newArrayProto = Object.create(oldArrayProto);
			const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
			arrMethods.forEach((methodName,arguments) => {
				console.log(arguments);
				oldArrayProto[methodName].call(this,...arguments);
				console.log('更新视图')
			})

		*/

    </script>
</body>
</html>