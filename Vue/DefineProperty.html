<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">
		
		let data = {
			book:{
				prdCode: 'BOOK0001',
				detail:{
					price: '69',
					subscribe:{
						title: 'Kindle'
					}
				}
			},
			msg: '书籍是人类进步的阶梯',
			arr: [1,3,3,4]
		}


		function getValueByObjPath(path){
			// 根据对象表达式获取对应的值，如obj.a.b
			let paths = path.split('.');
			// 函数柯里化
			return function(data){
				let res = data;
				let prop;
				while(prop = paths.shift()){
					res = res[prop]
				}
				return res;
			}
		}

    // 判断是实例属性还是原型属性
		function hasPrototypeProperty(obj, key) {
			// 实例属性：false，原型属性：true
			return !obj.hasOwnProperty(key) && (key in obj);
		}

		class Dep{
			constructor(){
				// 存放观察者wather
				this.subs = [];
			}
			addSub(sub){
				this.subs.push(sub)
			}
			// 收集观察者watcher
			depend(){
				// Dep.target是全局唯一值
				if(Dep.target){
					this.addSub(Dep.target);
				}
			}
      // 数据变化，派发watcher执行对应方法
			notify(){
				// 潜复制
				const subs = this.subs.slice();
				for(let i = 0;i<subs.length;i++){
					subs[i].update();
				}
			}
		}

		class Watcher{
			// 变量命名原则：内部数据使用下划线开头，只读数据用$开头
			constructor(data,objPath,callback){
				this._data = data;
				this._objPath = objPath;// 观察的表达式(属性路径)，如obj.a.b 在源码中第一次new Watcher 时传入的是 updateComponent 主要是调用_render(渲染虚拟DOM)和_update(将vnode渲染成真实DOM)函数的作用
				this._callback = callback;// 观察的表达式变化时触发的回调函数
				this._value = this.get();// 得到指定路径的value值，会得到初始值，触发 getter
			}
			get(){
				// 设置 watcher 实例对象为全局属性 watcherTarget
				Dep.watcherTarget = this;
				return getValueByObjPath(this._objPath)(this._data);
			}
			update(){
				this._value = getValueByObjPath(this._objPath)(this._data);
				// 当数据变化 执行回调函数 更新视图
				this._callback();
			}
		}



		// 相当于声明了一个val变量来做初始值和连接get和set，使val和getter/setter函数形成一个闭包
		// 目的就是给data对象的每个属性添加getter和setter方法，进行劫持
		function defineReactive(data,key,val){
			// 在__ob__属性中新增一个Dep实例
			let dep = new Dep();
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				// 这里如果有多层嵌套对象，那么val就会是下一个嵌套的对象
				// 这里的val = data[key]以及observe(val)对于循环对象变成响应式对象非常关键，会将一个嵌套对象defineReactive完之后再回到外层defineReactive，然后继续下一个data的对象defineReactive
				// var = {a:'aa',b:{c:'cc'},d:'dd'} defineReactive顺序为 a -> c -> b -> d;
				val = data[key]
			}
			// 这里调用obseve的作用是循环递归各个层级的对象，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
			// 被defineReactive化的属性都通过闭包引用属于自己的 Dep 实例和 childOb对象
			// 这里的childOb就是Observer的实例
			let childOb = observe(val);
			Object.defineProperty(data,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，属性==== ',key ,'  val值====  ',val)
					if(Dep.target){
						// 收集依赖
						dep.depend()
						if(childOb) childOb.dep.depend();
					}
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用val的值=== ',val,'  newValue的值===  ',newValue);
					// 当设置属性为对象的时候也要observe，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
					observe(val);
					if(newValue === val) return;
					val = newValue;
					// 通知视图更新
					dep.notify();
				}
			})
		}

		// 将传入的对象走一层 Object.deineProperty方法来定义其属性
		const def = (obj,key,value,enumerable) => {
			// 这里传进来的value值是Observer的实例，保存在__ob__属性上，属性是__ob__ 也就是通过观察对象上是否有__ob__属性来判断对象是否有setter和getter函数，是否被响应式处理
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,// 是否可枚举
				writable: true, // 是否可写
				configurable: true // 
			})
		}


		// const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
		// // 获取数组原型对象，原型对象上有数组方法如push\pop等
		// const arrayProto = Array.prototype;
		// // 以数组原型对象(arrayProto)为原型，创建一个原型对象上含有数组方法的对象，也就是该对象是可以调用
		// const newArrayPrototypeObj = Object.create(arrayProto);
		// console.log(newArrayPrototypeObj instanceof Array)
		// arrMethods.forEach(methodName => {
		// 	// 保存数组原型上的方法
		// 	const original = arrayProto[methodName];
		// 	def(newArrayPrototypeObj,methodName,function(...arguments){
		// 		// 用到this，不能用箭头函数
		// 		// arrMethods也有数组原型中的方法了
		// 		console.log('改写数组方法')
		// 		// original.apply(this,arguments);
		// 	},false)
		// })

		// 实现各个层级对象的属性能够被侦测（即被观察observe，添加getter和setter函数）的类，有多少个对象就有多少个Observer实例
		class Observer{
			constructor(obj){
				// 新增一个Dep类实例，每个Observer的实例都会有个Dep实例
				let dep = new Dep();
				// 这里的this是Observer的实例
				// obj.__ob__ = this; 那么每一个被监控的对象都会有一个__ob__属性，__ob__属性上会有walk和observeArray方法了。但是直接这么定义会导致死循环，一直会去执行observeArray和walk等方法
				def(obj,'__ob__',this)
				if(Array.isArray(obj)){
					obj.__proto__ = arrayMethodsChange();
					// Object.setPrototypeOf(obj,arrayMethodsChange);
					this.observeArray(obj);
				}else{
					this.walk(obj)
				}
			}
			// 遍历每个对象的层级
			walk (obj) {
				// data属性组成的数组
				const keys = Object.keys(obj)
				for (let i = 0; i < keys.length; i++) {
					defineReactive(obj, keys[i])
				}
			}
			// 劫持数组里的对象
			observeArray(arr){
				for(let i = 0;i<arr.length;i++){
					observe(arr[i])
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			// 必须保证要观察的data是对象
			if(typeof obj !== 'object' || obj === null) return;
			// ob变量存储的是Observer的实例，__ob__是Observer实例
			var ob;
			// 初始的ob是undefined，通过new Observer的目的是让ob成为Observer的实例，在Observer上通过def来定义__ob__属性，即可给data上的每个对象添加__ob__属性
			if(typeof obj.__ob__ !== 'undefined'){
				ob = obj.__ob__;
			}else{
				ob = new Observer(obj);
			}
			// 最终返回的ob都是Observer实例，最终的目的是给data上的每个对象新增getter和setter方法，同时也会新增一个__ob__实例属性，即实现响应式
			return ob;
		}

		function arrayMethodsChange(){
			// 其中slice不会改变原数组，所以不需要重写，劫持
			const arrMethods = ['push','pop','shift','unshift','splice','sort','reserve'];
			// 获取数组原型上的方法
			const oldArrayProtope = Array.prototype;
			// 以oldArrayProtope为原型,创建一个含有数组方法的对象
			// newArrayPrototypeObj.__proto__ = oldArrayProtope;
			const newArrayPrototypeObj = Object.create(oldArrayProtope);
			// 传进来的value值.__proto__ = newArrayPrototypeObj;
			// 会查找重写的push等方法，没有则通过原型链继续网上找方法
			arrMethods.forEach(methodName => {
				// 给newArrayPrototypeObj添加方法
				newArrayPrototypeObj[methodName] = function(...args){
					// 调用原数组的方法才能真正的执行
					// 因为这里的方法都是传进来需要被检测的对象调用的，所以this就是指传进来需要被检测的对象
					// 在Observer类上给每个被劫持的对象都添加了__ob__属性，__ob__属性就是Observer实例，所以有walk和observeArray的方法
					let ob = this.__ob__;
					const result = oldArrayProtope[methodName].call(this,...args);
					// 如果添加的元素还是对象
					let inserted;// 插入的元素
					switch(methodName){
						// push和unshift的就是插入元素
						case 'push':
						case 'unshift':
							inserted = args;
						// 可以新增 删除 修改
						// arr.splice(0,1,'插入的数组')
						case 'splice':
							inserted = args.splice(2);
						default:
							break;
					}
					// 如果插入的元素还是数组则需要继续劫持
					if(inserted) ob.observeArray(inserted);
				}
			})
			return newArrayPrototypeObj;
		}

		observe(data);
    </script>
</body>
</html>