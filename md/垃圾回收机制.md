## GC算法(垃圾回收机制)

GC可以找到内存中的垃圾、并释放和回收空间，常见的GC算法

- 引用计数
- 标记清除
- 标记整理
- 分代回收

### 引用计数算法

核心思想：设置引用数，判断当前引用数是否为0，引用数为0时立即回收

优点：发现垃圾时会立即回收，最大限度减少程序的暂停。
缺点：无法回收循环引用的对象，时间开销大（因为引用数值需要监听变化）

```javascript
const obj1 = {num:1};
const obj2 = {num:2};
const arr = [obj1.num,obj2.num];
// 这段代码执行完之后，obj1和obj2依然是被arr引用，所以引用数不是0 ，不会被当成垃圾对象回收
function fn(){
  a = 1;
  b = 2;
}
fn();
// 因为a和b是定义在全局上的，所以即使fn函数执行完之后，也依然能够在window中找到a和b，所以引用数不是0，就不会当成垃圾对象回收
function fn(){
  const c = 1;
  const d = 2;
}
fn();
// c和d在fn函数执行完之后，引用数是0 ，所以会自动被当成垃圾对象回收
function fn(){
  const obj1 = {}
  const obj2 = {}
  obj1.name = obj2;
  obj2.name = obj1;
}
fn();
// 在执行完fn之后，发现obj1和obj2中有对象是相互引用的，所以计数算法没法将其回收
```

### 标记清除算法

核心思想：分标记和清除二哥阶段完成

遍历所有可达对象(深层次)找标记活动对象，没有被标记的对象则会被回收相应的空间。
相对于引用计数算法回收机制来说，标记清除算法是可以清除循环引用对象的垃圾空间，但是释放的空间有可能会被碎片化