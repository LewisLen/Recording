<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">
		
		let data = {
			// book:{
			// 	prdCode: 'BOOK0001',
			// 	detail:{
			// 		price: '69',
			// 		subscribe:{
			// 			title: 'Kindle'
			// 		}
			// 	}
			// },
			// msg: '书籍是人类进步的阶梯',
			arr: [1,3,3,4]
		}

		// 判断是实例属性还是原型属性
		function hasPrototypeProperty(obj, key) {
			// 实例属性：false，原型属性：true
			return !obj.hasOwnProperty(key) && (key in obj);
		}

		// 相当于声明了一个val变量来做初始值和连接get和set，使val和getter/setter函数形成一个闭包
		function defineReactive(target,key,val){
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				// 这里如果有多层嵌套对象，那么val就会是下一个嵌套的对象
				// 这里的val = target[key]以及observe(val)对于循环对象变成响应式对象非常关键，会将一个嵌套对象defineReactive完之后再defineReactive下一个data的对象
				val = target[key]
			}
			// 这里调用obseve的作用是循环递归各个层级的对象，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
			observe(val);
			Object.defineProperty(target,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，属性==== ',key ,'  val值====  ',val)
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用val的值=== ',val,'  newValue的值===  ',newValue);
					// 当设置属性为对象的时候也要observe，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
					observe(val);
					if(newValue === val) return;
					val = newValue
					console.log("数据被改变此处可更新视图")
				}
			})
		}

		// 将传入的对象走一层Object.deineProperty方法来定义其属性
		const def = (obj,key,value,enumerable) => {
			// 这里传进来的value值是Observer的实例，属性是__ob__ 也就是通过观察对象上是否有__ob__属性来判断对象是否有setter和getter函数，是否被响应式处理
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,// 是否可枚举
				writable: true, // 是否可写
				configurable: true // 
			})
		}


		const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
			// 获取数组原型上的方法
			const arrayProto = Array.prototype;
			// 以arrayProto为原型,创建一个含有数组方法的对象
			const newArrayPrototypeObj = Object.create(arrayProto);
			console.log(newArrayPrototypeObj instanceof Array)
			arrMethods.forEach(methodName => {
				// 保存数组原型上的方法
				const original = arrayProto[methodName];
				def(newArrayPrototypeObj,methodName,function(...args){
					// 用到this，不能用箭头函数
					// arrMethods也有数组原型中的方法了
					console.log('改写数组方法')
					// original.apply(this,args);
				},false)
			})

		// 实现各个层级对象的属性能够被侦测（即被观察observe）的类，有多少个对象就有多少个Observer实例
		class Observer{
			constructor(obj){
				console.log('Observer观察者类，obj值===',obj)
				// 将类的实例用defineProperty定义属性，这里的this是Observer的实例
				def(obj,'__ob__',this)
				console.log('Observer====obj',obj)
				if(Array.isArray(obj)){
					// 数组需要通过改写数组方法来使其可以新增getter和setter方法，变成响应式
					Object.setPrototypeOf(obj,arrayMethodsChange());
					this.observeArray(obj);
				}else{
					this.walk(obj)
				}
			}
			// 遍历每个对象的层级
			walk (obj) {
				// data属性组成的数组
				const keys = Object.keys(obj)
				for (let i = 0; i < keys.length; i++) {
					// 给data属性对象添加getter和setter方法
					defineReactive(obj, keys[i])
				}
			}
			observeArray (arr) {
				console.log('arr===',arr)
				for (let i = 0, l = arr.length; i < l; i++) {
					observe(arr[i])
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			// 必须保证要观察的data是对象
			if(typeof obj !== 'object' || obj === null) return;
			// ob变量存储的是Observer的实例，__ob__是Observer实例的属性
			var ob;
			// 初始的ob是undefined，通过new Observer的目的是让ob成为Observer的实例，在Observer上通过def来定义__ob__属性，即可给data上的每个对象添加__ob__属性
			if(typeof obj.__ob__ !== 'undefined'){
				ob = obj.__ob__;
			}else{
				ob = new Observer(obj);
			}
			// 最终返回的ob都是Observer实例，最终的目的是给data上的每个对象新增getter和setter方法，同时也会新增一个__ob__实例属性，即实现响应式
			return ob;
		}


		function arrayMethodsChange(){
			const arrMethods = ['push','pop','unshift','shift','splice','sort','reserve'];
			// 获取数组原型上的方法
			const arrayProto = Array.prototype;
			// 以arrayProto为原型,创建一个含有数组方法的对象
			// 即newArrayPrototypeObj是一个有上被述改写的9个数组方法
			const newArrayPrototypeObj = Object.create(arrayProto);
			arrMethods.forEach(methodName => {
				// 保存数组原型上的方法
				const original = arrayProto[methodName];
				def(newArrayPrototypeObj,methodName,function(...args){
					// 用到this，不能用箭头函数
					// arrMethods也有数组原型中的方法了

					// todo 这一段还不是很懂
					// 这里的this.__ob__就是传入的data数组中会有__ob__属性，因为该数组也是data对象的一个属性值，所以在遍历最外层对象的时候，就已经给数组添加了__ob__属性
					const ob = this.__ob__;
					let inserted = [];
					// 这里判读的目的是将新插入的元素也要是响应式
					switch(methodName){
						case 'push':
						case 'unshift':
							inserted = args;
							break;
						case 'splice':
							// splice(index,number,插入项)
							// 所以这里是从第二项开始取子数组
							inserted = args.splice(2);
							break;
					}
					if(inserted){
						ob.observeArray(inserted);
					}
					// todo 这一段还不是很懂
					original.apply(this,args);
				},false)
			})
			return newArrayPrototypeObj;
		}

		observe(data.arr);


		// 简写版本
		/*
			const data = {
				data:{
					list:{
						type: '类型111'
					}
				}
			}

			function observer(target){
				if(typeof target !== 'object' || target === null){
					return target
				}
				for(let key in target){
					defineReactive(target,key,target[key]);
				}
			}


			function defineReactive(target,key,value){
				// 递归监听数据中的嵌套对象
				observer(value);
				Object.defineProperty(target,key,{
					get(){
						return value
					},
					set(newValue){
						// 在设置的时候也有可能是对象，也需要深度监听对象
						observer(value);
						if(newValue === value) return;
						val = newValue;
						console.log('更新视图')
					}
				})
			}

			observer(data);
			console.log(data)
			// 删除和新增data没有的属性没法响应式

			// 	新增对数组的响应式
			const oldArrayProto = Array.prototype;
			const newArrayProto = Object.create(oldArrayProto);
			const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
			arrMethods.forEach((methodName,args) => {
				console.log(args);
				oldArrayProto[methodName].call(this,...args);
				console.log('更新视图')
			})

		*/

    </script>
</body>
</html>