<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">

		let person = {
			// a:{
			// 	b:{
			// 		name: 'len'
			// 	}
			// },
			// d:{
			// 	age: '00'
			// },
			name: "Len"
		}

		// 相当于在最外层加个中间的变量val，和getter/setter形成一个闭包
		function defineReactive(target,key,val){
			console.log('defineReactive函数');
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				val = target[key]
			}
			Object.defineProperty(target,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，值为==== ',val)
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用旧值为==== ',val);
					console.log('defineReactive的setter函数被调用新值为==== ',newValue);
					if(newValue === val) return;
					val = newValue
					console.log("更新视图")
				}
			})
		}

		// 将传入的对象走一层Object.deineProperty方法来定义
		const def = (obj,key,value,enumerable) => {
			console.log('def====obj',obj)
			console.log('def====key',key)
			console.log('def====value',value)
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,
				writable: true,
				configurable: true
			})
		}

		// 实现各个层级对象的属性能够被侦测（即被观察observe）的类
		class Observer{
			constructor(obj){
				console.log('Observer观察者类，obj值===',obj)
				// 给类的实例用defineProperty定义
				// 这里的this是Observer的实例
				console.log('Oberver观察者类的实例this====',this)
				def(obj,'__ob__',this)
				this.walk(obj)
			}
			// 遍历每个对象的层级
			walk (obj) {
				const keys = Object.keys(obj)
				for (let i = 0; i < keys.length; i++) {
					console.log('walk===',keys[i])
					defineReactive(obj, keys[i] )
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			console.log('observe函数，传入的obj一定得是对象===',obj)
			if(typeof obj !== 'object' || obj === null) return;
			// ob变量存储的是Observer的实例__ob__是Observer实例的属性
			var ob;
			console.log('初始的ob=====',ob,'typeof ob====',typeof ob)
			if(typeof obj.__ob__ !== 'undefined'){
				console.log('obj.__ob__属性存在')
				ob = obj.__ob__;
			}else{
				console.log('obj.__ob__属性不存在')
				ob = new Observer(obj);
			}
			console.log('最终返回的ob=====',ob)
			return ob;
		}

		observe(person);



		/*
			const data = {
				name: 'len',
				age: '100',
				arr: [1]
			}

			function observer(target){
				if(typeof target !== 'object' || target === null){
					return target
				}
				for(let key in target){
					defineReactive(target,key,target[key]);
				}
			}


			function defineReactive(target,key,value){
				// 递归监听数据中的嵌套对象
				observer(target);
				Object.defineProperty(target,key,{
					get(){
						return value
					},
					set(newValue){
						// 在设置的时候也有可能是对象，也需要深度监听对象
						observer(value);
						if(newValue === value) return;
						val = newValue;
						console.log('更新视图')
					}
				})
			}

			observer(data);
			console.log(data)
			// 删除和新增data没有的属性没法响应式

			// 	新增对数组的响应式
			const oldArrayProto = Array.prototype;
			const newArrayProto = Object.create(oldArrayProto);
			const arrMethods = ['push','pop','unshift','splice','splice'];
			arrMethods.forEach((methodName,args) => {
				console.log(args);
				oldArrayProto[methodName].call(this,...args);
				console.log('更新视图')
			})

		*/


		
		/*
			let data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			// 模拟vue的实例
			let vm = {}
			// Object.keys循环对象属性
			Object.keys(data).forEach(key => {
				// 数据劫持：当访问或者设置vm中的数据时做的一些操作
				Object.defineProperty(vm,key,{
					get(){
						console.log('getter')
						document.querySelector("#app").textContent = data[key];
						return data[key]
					},
					set(newVal){
						console.log('setter');
						data[key] = newVal;
						document.querySelector("#app").textContent = data[key];
						return;
					}
				})
			})
			console.log(vm.msg)
			*/

			/*
			let _data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			const _vm = new Proxy(_data,{
				get(target,key){
					console.log('gettter',' key==',key,' taget[key===]',target[key])
					return target[key]
				},
				set(target,key,newValue){
					console.log('settter',' key==',key,' taget[key===]',target[key],' newValue===',newValue)
					if(target[key] === newValue){
						return;
					}
					target[key] = newValue;
					document.querySelector('#root').textContent = target[key];
				}
			})
			*/
    </script>
</body>
</html>