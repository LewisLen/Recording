<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">
		
		let person = {
			a:{
				b:{
					name: 'len'
				}
			},
			d:{
				age: '00'
			},
			name: "Len",
			arr: [1,2,3,4]
		}

		// 相当于在最外层加个中间的变量val，和getter/setter形成一个闭包
		function defineReactive(target,key,val){
			console.log('defineReactive函数');
			console.log('defineReactive函数val====',val)
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				// 这里如果有多层嵌套对象，那么val就会是下一个嵌套的对象
				val = target[key]
			}
			// 这里调用obseve的作用是循环递归各个层级的对象，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
			observe(val);
			Object.defineProperty(target,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，值为==== ',val)
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用旧值为==== ',val);
					console.log('defineReactive的setter函数被调用新值为==== ',newValue);
					// 当设置属性为对象的时候也要observe，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
					observe(val);
					if(newValue === val) return;
					val = newValue
					console.log("更新视图")
				}
			})
		}

		// 将传入的对象走一层Object.deineProperty方法来定义
		const def = (obj,key,value,enumerable) => {
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,
				writable: true,
				configurable: true
			})
		}

		// 实现各个层级对象的属性能够被侦测（即被观察observe）的类
		class Observer{
			constructor(obj){
				console.log('Observer观察者类，obj值===',obj)
				// 给类的实例用defineProperty定义
				// 这里的this是Observer的实例
				console.log('Oberver观察者类的实例this====',this)
				def(obj,'__ob__',this)
				if(Array.isArray(obj)){
					console.log('数组====')
					Object.setPrototypeOf(obj,arrayMethodsChange);
				}else{
					this.walk(obj)
				}
			}
			// 遍历每个对象的层级
			walk (obj) {
				const keys = Object.keys(obj)
				console.log('keys=====',keys)
				console.log('obj=====',obj)
				for (let i = 0; i < keys.length; i++) {
					console.log('walk===',keys[i])
					defineReactive(obj, keys[i] )
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			console.log('observe函数，传入的obj一定得是对象===',obj)
			if(typeof obj !== 'object' || obj === null) return;
			// ob变量存储的是Observer的实例__ob__是Observer实例的属性
			var ob;
			console.log('初始的ob=====',ob,'typeof ob====',typeof ob);
			if(typeof obj.__ob__ !== 'undefined'){
				console.log('obj.__ob__属性存在')
				ob = obj.__ob__;
			}else{
				console.log('obj.__ob__属性不存在')
				ob = new Observer(obj);
			}
			console.log('最终返回的ob',ob,'是Observer的实例')
			return ob;
		}


		function arrayMethodsChange(){
			const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
			// 获取数组原型上的方法
			const oldArrayProtope = Array.prototype;
			// 以oldArrayProtope为原型,创建一个含有数组方法的对象
			const newArrayPrototypeObj = Object.create(oldArrayProtope);
			arrMethods.forEach(methodName => {
				def(newArrayPrototypeObj,methodName,function(){
					console.log('hhhhh')
					oldArrayProtope[methodName].call(this,...arguments);
				},false)
			})
			console.log('newArrayPrototypeObj===',newArrayPrototypeObj)
			return newArrayPrototypeObj;
		}

		observe(person);



		/*
			const data = {
				name: 'len',
				age: '100',
				arr: [1]
			}

			function observer(target){
				if(typeof target !== 'object' || target === null){
					return target
				}
				for(let key in target){
					defineReactive(target,key,target[key]);
				}
			}


			function defineReactive(target,key,value){
				// 递归监听数据中的嵌套对象
				observer(target);
				Object.defineProperty(target,key,{
					get(){
						return value
					},
					set(newValue){
						// 在设置的时候也有可能是对象，也需要深度监听对象
						observer(value);
						if(newValue === value) return;
						val = newValue;
						console.log('更新视图')
					}
				})
			}

			observer(data);
			console.log(data)
			// 删除和新增data没有的属性没法响应式

			// 	新增对数组的响应式
			const oldArrayProto = Array.prototype;
			const newArrayProto = Object.create(oldArrayProto);
			const arrMethods = ['push','pop','unshift','splice','splice','sort','reserve'];
			arrMethods.forEach((methodName,args) => {
				console.log(args);
				oldArrayProto[methodName].call(this,...args);
				console.log('更新视图')
			})

		*/


		
		/*
			let data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			// 模拟vue的实例
			let vm = {}
			// Object.keys循环对象属性
			Object.keys(data).forEach(key => {
				// 数据劫持：当访问或者设置vm中的数据时做的一些操作
				Object.defineProperty(vm,key,{
					get(){
						console.log('getter')
						document.querySelector("#app").textContent = data[key];
						return data[key]
					},
					set(newVal){
						console.log('setter');
						data[key] = newVal;
						document.querySelector("#app").textContent = data[key];
						return;
					}
				})
			})
			console.log(vm.msg)
			*/

			/*
			let _data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			const _vm = new Proxy(_data,{
				get(target,key){
					console.log('gettter',' key==',key,' taget[key===]',target[key])
					return target[key]
				},
				set(target,key,newValue){
					console.log('settter',' key==',key,' taget[key===]',target[key],' newValue===',newValue)
					if(target[key] === newValue){
						return;
					}
					target[key] = newValue;
					document.querySelector('#root').textContent = target[key];
				}
			})
			*/
    </script>
</body>
</html>