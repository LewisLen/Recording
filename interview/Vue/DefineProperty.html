<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vue2.X响应式原理</title>
<body>
    <div id="app">
    </div>
    <script type="text/javascript">
		
		let person = {
			a:{
				b:{
					name: 'len'
				}
			},
			d:{
				age: '00'
			},
			name: "Len",
			arr: [1,2,3,4]
		}

		// 相当于在最外层加个中间的变量val，和getter/setter形成一个闭包
		function defineReactive(target,key,val){
			console.log('defineReactive函数');
			console.log('defineReactive函数val====',val)
			if(arguments.length === 2){
				// 如果没有传初始值，则读取赋值所传的key/value值
				// 这里如果有多层嵌套对象，那么val就会是下一个嵌套的对象
				val = target[key]
			}
			// 这里调用obseve的作用是循环递归各个层级的对象，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
			observe(val);
			Object.defineProperty(target,key,{
				enumerable: true,// 可枚举
				configurable: true,
				get(){
					// 当读取name属性时调用
					console.log('defineReactive的getter函数被调用，值为==== ',val)
					return val
				},
				set(newValue){
					// 当设置name属性时调用
					console.log('defineReactive的setter函数被调用旧值为==== ',val);
					console.log('defineReactive的setter函数被调用新值为==== ',newValue);
					// 当设置属性为对象的时候也要observe，使其都是Observer的实例，最终每个属性都会被defineReactive,拥有getter和setter函数，变成响应式
					observe(val);
					if(newValue === val) return;
					val = newValue
					console.log("更新视图")
				}
			})
		}

		// 将传入的对象走一层Object.deineProperty方法来定义
		const def = (obj,key,value,enumerable) => {
			Object.defineProperty(obj,key,{
				value,
				enumerable: !!enumerable,// 不可枚举
				configurable: false
			})
		}

		// 实现各个层级对象的属性能够被侦测（即被观察observe）的类
		class Observer{
			constructor(obj){
				// 这里的this是Observer的实例
				// obj.__ob__ = this; 那么每一个被监控的对象都会有一个__ob__属性，__ob__属性上会有walk和observeArray方法了。但是直接这么定义会导致死循环，一直会去执行observeArray和walk等方法
				def(obj,'__ob__',this)
				if(Array.isArray(obj)){
					obj.__proto__ = arrayMethodsChange();
					// Object.setPrototypeOf(obj,arrayMethodsChange);
					this.observeArray(obj);
				}else{
					this.walk(obj)
				}
			}
			// 遍历每个对象的层级
			walk (obj) {
				const keys = Object.keys(obj)
				for (let i = 0; i < keys.length; i++) {
					defineReactive(obj, keys[i] )
				}
			}
			// 劫持数组里的对象
			observeArray(arr){
				for(let i = 0;i<arr.length;i++){
					observe(arr[i])
				}
			}
	}

		// 判断传入的对象是否为嵌套对象，实现各个层级的属性都能够被defineProperty定义
		function observe(obj){
			console.log('observe函数，传入的obj一定得是对象===',obj)
			if(typeof obj !== 'object' || obj === null) return;
			// __ob__是Observer实例
			var ob;
			if(typeof obj.__ob__ !== 'undefined'){
				ob = obj.__ob__;
			}else{
				ob = new Observer(obj);
			}
			return ob;
		}


		function arrayMethodsChange(){
			// 其中slice不会改变原数组，所以不需要重写，劫持
			const arrMethods = ['push','pop','shift','unshift','splice','sort','reserve'];
			// 获取数组原型上的方法
			const oldArrayProtope = Array.prototype;
			// 以oldArrayProtope为原型,创建一个含有数组方法的对象
			// newArrayPrototypeObj.__proto__ = oldArrayProtope;
			const newArrayPrototypeObj = Object.create(oldArrayProtope);
			// 传进来的value值.__proto__ = newArrayPrototypeObj;
			// 会查找重写的push等方法，没有则通过原型链继续网上找方法
			arrMethods.forEach(methodName => {
				// 给newArrayPrototypeObj添加方法
				newArrayPrototypeObj[methodName] = function(...args){
					// 调用原数组的方法才能真正的执行
					// 因为这里的方法都是传进来需要被检测的对象调用的，所以this就是指传进来需要被检测的对象
					// 在Observer类上给每个被劫持的对象都添加了__ob__属性，__ob__属性就是Observer实例，所以有walk和observeArray的方法
					let ob = this.__ob__;
					const result = oldArrayProtope[methodName].call(this,...args);
					// 如果添加的元素还是对象
					let inserted;// 插入的元素
					switch(methodName){
						// push和unshift的就是插入元素
						case 'push':
						case 'unshift':
							inserted = args;
						// 可以新增 删除 修改
						// arr.splice(0,1,'插入的数组')
						case 'splice':
							inserted = args.splice(2);
						default:
							break;
					}
					// 如果插入的元素还是数组则需要继续劫持
					if(inserted) ob.observeArray(inserted);
				}
			})
			return newArrayPrototypeObj;
		}

		observe(person);
		console.log(person)



		
		/*
			let data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			// 模拟vue的实例
			let vm = {}
			// Object.keys循环对象属性
			Object.keys(data).forEach(key => {
				// 数据劫持：当访问或者设置vm中的数据时做的一些操作
				Object.defineProperty(vm,key,{
					get(){
						console.log('getter')
						document.querySelector("#app").textContent = data[key];
						return data[key]
					},
					set(newVal){
						console.log('setter');
						data[key] = newVal;
						document.querySelector("#app").textContent = data[key];
						return;
					}
				})
			})
			console.log(vm.msg)
			*/

			/*
			let _data = {
				msg: 'Hello',
				name: 'Len'
			}
			
			const _vm = new Proxy(_data,{
				get(target,key){
					console.log('gettter',' key==',key,' taget[key===]',target[key])
					return target[key]
				},
				set(target,key,newValue){
					console.log('settter',' key==',key,' taget[key===]',target[key],' newValue===',newValue)
					if(target[key] === newValue){
						return;
					}
					target[key] = newValue;
					document.querySelector('#root').textContent = target[key];
				}
			})
			*/
    </script>
</body>
</html>